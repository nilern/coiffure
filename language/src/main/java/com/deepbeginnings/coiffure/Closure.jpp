package com.deepbeginnings.coiffure;

import clojure.lang.AFunction;
import clojure.lang.Util;

import com.oracle.truffle.api.Truffle;

#define PARAM(param) Object param
#define PARAMS0()
#define PARAMS1(param) PARAM(param)
#define PARAMS2(param, ...) PARAM(param), PARAMS1(__VA_ARGS__)
#define PARAMS3(param, ...) PARAM(param), PARAMS2(__VA_ARGS__)
#define PARAMS4(param, ...) PARAM(param), PARAMS3(__VA_ARGS__)

#define ARG(arg) Util.ret1(arg, arg = null)
#define ARGS0()
#define ARGS1(arg) , ARG(arg)
#define ARGS2(arg, ...) , ARG(arg) ARGS1(__VA_ARGS__)
#define ARGS3(arg, ...) , ARG(arg) ARGS2(__VA_ARGS__)
#define ARGS4(arg, ...) , ARG(arg) ARGS3(__VA_ARGS__)

#define INVOKE(argc, params, args) \
    public Object invoke(params) { \
            final MethodNode method = methods[argc]; \
            if (method != null) { \
                return Truffle.getRuntime().createCallTarget(method) \
                        .call(this args); \
            } else { \
                return throwArity(argc); \
            } \
        }

public class Closure extends AFunction implements IClosure {
    private final MethodNode[] methods;
    private final Object[] clovers; // OPTIMIZE: Closure extends DynamicObject?

    public Closure(final MethodNode[] methods, final Object[] clovers) {
        this.methods = methods;
        this.clovers = clovers;
    }

    @Override
    public Object clover(final int index) { return clovers[index]; }

    @Override INVOKE(0, PARAMS0(), ARGS0())
    @Override INVOKE(1, PARAMS1(arg), ARGS1(arg))
    @Override INVOKE(2, PARAMS2(arg1, arg2), ARGS2(arg1, arg2))
    @Override INVOKE(3, PARAMS3(arg1, arg2, arg3), ARGS3(arg1, arg2, arg3))
    @Override INVOKE(4, PARAMS4(arg1, arg2, arg3, arg4), ARGS4(arg1, arg2, arg3, arg4))
}
